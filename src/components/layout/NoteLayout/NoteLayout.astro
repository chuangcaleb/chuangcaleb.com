---
import type { MarkdownHeading } from "astro";
import BaseMain from "~/components/layout/BaseMain.astro";
import NoteList from "~/components/layout/NoteList.astro";
import type { MetadataProps } from "./components/metadata/Metadata.astro";
import Metadata from "./components/metadata/Metadata.astro";
import Toc from "./components/toc/Toc.astro";

interface Props {
  title: string;
  headings?: MarkdownHeading[];
  metadata?: MetadataProps;
}

const { title, headings = [], metadata = {} } = Astro.props;

// collection
const { collectionItems, series: isOrdered = false } = metadata;
const isCollection = !!collectionItems?.length;
const collectionData = isCollection && { isOrdered, items: collectionItems };
---

<BaseMain title={title}>
  <Fragment slot="sheetBody">
    <h3>{title}</h3>
    <Metadata metadata={metadata} />
    <slot name="sidebar" />
    <Toc headings={headings} />
  </Fragment>
  <article class="note-body">
    <aside class="flow-lg">
      <Metadata metadata={metadata} />
      <div class="aside-sticky flow no-scrollbar">
        <slot name="sidebar" />
        <Toc headings={headings} />
      </div>
    </aside>
    <div class="article-main full cgrid prose flow-lg">
      <slot />
      {
        collectionData && (
          <Fragment>
            <hr />
            <NoteList class="feature" {...collectionData} />
          </Fragment>
        )
      }
    </div>
  </article>
</BaseMain>

<style>
  .note-body {
    display: grid;
    grid-template-columns: 1fr 26vw;
    padding-bottom: var(--space-3xl);
  }

  aside {
    padding-inline: var(--space-m);
    padding-bottom: var(--space-2xs);
  }
  .aside-sticky {
    position: sticky;
    top: var(--space-xs);
    height: min(100%, 100vh);
    width: 100%;
    overflow-x: hidden;
    padding-block-end: var(--space-l);
  }
  @media (width < 900px) {
    .note-body {
      grid-template-columns: 1fr;
    }
    aside {
      display: none;
    }
  }
  .article-main {
    grid-row-start: 1;
    grid-column: 1;

    & :global(:is(h1)) {
      grid-column-end: feature;
    }
    & :global(h1 + *) {
      --flow-space: var(--size-relative-7);
    }
  }
</style>

<script>
  function initToc() {
    const setCurrentHeading: IntersectionObserverCallback = (entries) => {
      // loop to each entries (headings) in the page
      for (let entry of entries) {
        // equivalent to the slug returned from pageHeadings
        const { id } = entry.target;
        // get the TOC link's element for the current entry
        const tocLinkEl = document.querySelector(`#toc a[href='#${id}']`);
        if (!tocLinkEl) return;

        // check if the entry is intersecting
        if (entry.isIntersecting) {
          // remove active class from all links
          document
            .querySelectorAll("#toc a")
            .forEach((e) => e.classList.remove("active"));
          // add active class to the currently active entry
          tocLinkEl.classList.add("active");
        }
      }
    };
    const observerOptions = {
      threshold: 1,
      rootMargin: "0px 0px -66%",
    };
    const observer = new IntersectionObserver(
      setCurrentHeading,
      observerOptions
    );
    // select all headings to observe
    const elToObserve = document.querySelectorAll("article :is(h2,h3,h4)");
    // finally, observe the elements
    elToObserve.forEach((el) => observer.observe(el));
  }
  initToc();
  document.addEventListener("astro:after-swap", initToc);
</script>
